def joyControl():
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_input_actions_to_default()
  set_safety_mode_transition_hardness(1)
  set_gravity([0.0, 0.0, 9.82])
  modbus_add_signal("127.0.0.1", 255, 128, 2, "L_leftRright", False)
  modbus_set_signal_update_frequency("L_leftRright", 10)
  modbus_add_signal("127.0.0.1", 255, 129, 2, "L_upDown", False)
  modbus_set_signal_update_frequency("L_upDown", 10)
  modbus_add_signal("127.0.0.1", 255, 130, 2, "R_leftRight", False)
  modbus_set_signal_update_frequency("R_leftRight", 10)
  modbus_add_signal("127.0.0.1", 255, 131, 2, "R_upDown", False)
  modbus_set_signal_update_frequency("R_upDown", 10)
  set_tool_voltage(0)
  set_tcp(p[0.0,0.0,0.0,0.0,0.0,0.0])
  set_payload(1.37,[-0.0012,8.0E-4,0.0896])
  global Calibration=p[0.7192112620422433,-3.094561024154357E-5,0.07160824369326191,-1.9270288006979581,1.9268843553934034,-0.5164089599345877]
  global snapshot=p[0.3966575043781791,0.29646644793352284,0.6501131280637167,-1.9280569656714217,1.925902539088866,-0.5164276559443902]
  # begin: URCap Installation Node
  #   Source: Robotiq_Wrist_Camera, 1.8.0, Robotiq Inc.
  #   Type: Camera
  
  ###########################################
  #######Vision urcap preamble start########
  
  logging_service = rpc_factory("xmlrpc","http://127.0.0.1:4747")
  # Converts a pose relative to the flange in the base frame.
  def get_T_in_base_from_flange(T_x_in_flange):
  
    T_flange_in_base = get_actual_tool_flange_pose()
  
    T_x_in_base = pose_trans(T_flange_in_base, T_x_in_flange)
  
    return T_x_in_base
  end
  
  # Search pose cartesian (camera pose)
  Calibration = p[0.497847, 0.312511, 0.385186, -1.92811, 1.92584, -0.516265]
  snapshot = p[0.503224, 0.321719, 0.476945, -1.92565, 1.92664, -0.52193]
  T_camera_in_flange = p[0.0, 0.05, 0.05, -0.5, 0.0, 0.0]
  snapshot_position_offset = p[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  ignore_snapshot_position = False
  
  # Open connection with vision service
  xmlrpc_server=rpc_factory("xmlrpc","http://127.0.0.1:4242")
  
  #######Vision urcap preamble end##########
  ###########################################
  
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq Insights, 1.5.0, Robotiq Inc.
  #   Type: Insights
  box_urcap_xmlrpc_connection = rpc_factory("xmlrpc", "http://localhost:5557/")
  req_result = box_urcap_xmlrpc_connection.publishProgramStartedEvent()
  if not(req_result):
    textmsg("publishProgramStartedEvent request failed")
  end
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq_Force_Copilot, 1.10.0, Robotiq Inc.
  #   Type: Force Copilot
  ###############################################################
  # Script file used to communicate with Robotiq's ft sensor
  # Version: 0.0.1
  ###############################################################

  node_rpc_server = rpc_factory("xmlrpc","http://localhost:4251/node")
  linalg = rpc_factory("xmlrpc","http://localhost:4251/linalg")

  global Fx = 0.0
  global Fy = 0.0
  global Fz = 0.0
  global Mx = 0.0
  global My = 0.0
  global Mz = 0.0
  global T_base_sensor = p[0,0,0,0,0,0]
  global tcp_wrench = [0,0,0,0,0,0]
  global base_wrench = [0,0,0,0,0,0]
  global rq_ft_sensor_connected = False
  global rq_active_node = 0
  global rq_elapsed_time = 0
  rq_force_protect_urcap = 0.0
  rq_torque_protect_urcap = 0.0
  rq_collision_detection_enabled = False
  rq_collision_detection_active_time = 0.0
  rq_halt_on_collision_detection = True
  sensor_wrench = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  rq_node_executor_thread_running = False


  rq_controller_time_step = get_steptime()

  def pose_to_list(p):
    return [p[0], p[1], p[2], p[3], p[4], p[5]]
  end

  def rq_init_path(pathId):
     initPathAnswer = node_rpc_server.initpath(pathId)
     verify_path_answer(initPathAnswer)
     return initPathAnswer[0]
  end

  def verify_path_answer(path_answer):
   initPathStatusCode = path_answer[1]
   handle_path_node_error_code(initPathStatusCode)
  end

  def handle_path_node_error_code(initPathStatusCode):
    if initPathStatusCode == -1:
      popup("Could not compute path with the selected options.", "Robotiq's FT Sensor", error=True)
    elif initPathStatusCode == 1:
      popup("Joint solution impossible. Change your starting position.", "Robotiq's FT Sensor", error=True)
    elif initPathStatusCode == 2:
      popup("Discontinuous path detected. Change your starting position.", "Robotiq's FT Sensor", error=True)
    elif initPathStatusCode == 3:
      popup("Path time limit has been reached. Increase the speed of your path or break it down in multiple shorter paths.", "Robotiq's FT Sensor", error=True)
    elif initPathStatusCode == 4:
      popup("Could not compute path with the selected options. Computing path timeout.", "Robotiq's FT Sensor", error=True)
    elif initPathStatusCode == 5:
      popup("Path computation was aborted.", "Robotiq's FT Sensor", error=True)
      end
    if initPathStatusCode != 0:
      halt
    end
  end

  def rq_zero_sensor():
    if (socket_open("127.0.0.1", 63350, "rq_ft_sensor_acc")):
        socket_send_string("SET ZRO", "rq_ft_sensor_acc")
        sleep(0.1)
        socket_close("rq_ft_sensor_acc")
    end
  end

  def rq_wait_ft_sensor_steady(timeout = 2000):

    max_mean_squared_error = [0.1, 0.1, 0.1, 0.0001, 0.0001, 0.0001]
    mean = sensor_wrench

    mean_squared_error = sensor_wrench
    i=0
    while i<6:
      mean_squared_error[i] = mean_squared_error[i] * mean_squared_error[i]
      i=i+1
    end

    is_sensor_steady = False
    alpha = 0.9
    timer = 0

    while (not is_sensor_steady) and (timer < timeout):
      sleep(0.008)
      timer = timer + 8

      i = 0
      while i < 6:
        mean[i] = alpha * mean[i] + (1.0 - alpha) * sensor_wrench[i]
        error = sensor_wrench[i] - mean[i]
        mean_squared_error[i] = alpha * mean_squared_error[i] + ((1.0 - alpha) * error * error)
        i = i+1
      end

      is_sensor_steady = True
      i = 0
      while (i < 6) and is_sensor_steady:
        is_sensor_steady = mean_squared_error[i] < max_mean_squared_error[i]
        i = i+1
      end
    end

    return is_sensor_steady
  end

  thread rq_elapsed_timer_ms():
    rq_elapsed_time = 0
  dt = 1000/125
    while True:
      rq_elapsed_time =  rq_elapsed_time + dt
      sync()
    end
  end

  def get_sensor_fx():
    return Fx
  end

  def get_sensor_fy():
    return Fy
  end

  def get_sensor_fz():
    return Fz
  end

  def get_sensor_mx():
    return Mx
  end

  def get_sensor_my():
    return My
  end

  def get_sensor_mz():
    return Mz
  end

  def get_applied_tcp_force(index):
    return -1.0 * tcp_wrench[index]
  end

  def get_applied_base_force(index):
    return -1.0 * base_wrench[index]
  end

  def express_vector_in_new_frame(T_from_to, V_from):
    Q_from_to = p[0, 0, 0, T_from_to[3], T_from_to[4], T_from_to[5]]
    V_to = pose_trans(pose_inv(Q_from_to), p[V_from[0], V_from[1], V_from[2], 0, 0, 0])
    return [V_to[0], V_to[1], V_to[2]]
  end

  def express_force_in_frame(T_from_to, wrench_from):
    F = express_vector_in_new_frame(T_from_to, [wrench_from[0], wrench_from[1], wrench_from[2]])
    T = express_vector_in_new_frame(T_from_to, [wrench_from[3], wrench_from[4], wrench_from[5]])
    return [F[0], F[1], F[2], T[0], T[1], T[2]]
  end

  thread read_force():


  if (not socket_open("127.0.0.1", 63351, "rq_ft_sensor_stream")):
    popup("Can't connect to the FT Sensor driver", "Robotiq's FT Sensor", error=True)
    halt
  end

  socket_close("rq_ft_sensor_stream")
  if (not socket_open("127.0.0.1", 63350, "rq_ft_sensor_stream")):
    popup("Can't connect to the FT Sensor driver", "Robotiq's FT Sensor", error=True)
    halt
  end

    if (not socket_open("127.0.0.1", 29999, "RQDashboardClient")):
      popup("Can't connect to the Dashboard server", "Robotiq's FT Sensor", error=True)
      halt
    end

    rq_collision_detection_active_count = 0
    rq_collision_detection_active = False

    while True:
        socket_send_string("READ DATA", "rq_ft_sensor_stream")
        rq_sensor_data = socket_read_ascii_float(6, "rq_ft_sensor_stream")

        if (rq_sensor_data[0] >= 6):
            Fx = rq_sensor_data[1]
            Fy = rq_sensor_data[2]
            Fz = rq_sensor_data[3]
            Mx = rq_sensor_data[4]
            My = rq_sensor_data[5]
            Mz = rq_sensor_data[6]
        else:
            Fx = 0.0
            Fy = 0.0
            Fz = 0.0
            Mx = 0.0
            My = 0.0
            Mz = 0.0
        end

        T_base_tcp = get_actual_tcp_pose()
        T_base_flange = get_actual_tool_flange_pose()
        T_flange_sensor = p[0, 0, 0.0375, 0, 0, 0]
        T_base_sensor = pose_trans(T_base_flange, T_flange_sensor)

        T_flange_tcp = pose_trans( pose_inv(T_base_flange), T_base_tcp)
        T_sensor_tcp = pose_trans( pose_inv(T_flange_sensor), T_flange_tcp)

        sensor_wrench = [Fx, Fy, Fz, Mx, My, Mz]
        tcp_wrench = wrench_trans(pose_inv(T_sensor_tcp), sensor_wrench)
        base_wrench = express_force_in_frame(pose_inv(T_base_tcp), tcp_wrench)


        write_output_float_register(TCP_FX_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[0])
        write_output_float_register(TCP_FY_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[1])
        write_output_float_register(TCP_FZ_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[2])
        write_output_float_register(TCP_MX_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[3])
        write_output_float_register(TCP_MY_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[4])
        write_output_float_register(TCP_MZ_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[5])

        if rq_collision_detection_enabled:
            if rq_collision_detection_active_time < (0.5*rq_controller_time_step):
                if norm([Fx, Fy, Fz]) > rq_force_protect_urcap:
                    rq_on_collision_detection("Force limit value exceeded.")
                elif norm([Mx, My, Mz]) > rq_torque_protect_urcap:
                    rq_on_collision_detection("Torque limit value exceeded.")
                end
            else:
                rq_collision_detection_active_time = rq_collision_detection_active_time + rq_controller_time_step
                if rq_collision_detection_active_time >= 1.0:
                    rq_collision_detection_active_time = 0.0
                end
            end
        end


    end
  end

  def rq_get_ft_sensor_state():
    socket_open("127.0.0.1",63350,"rq_ft_sensor_state")
    socket_send_string("CURRENT STATE", "rq_ft_sensor_state")
    rq_sensor_state = socket_read_string("rq_ft_sensor_state")
    socket_close("rq_ft_sensor_state")

    if rq_sensor_state == "":
      rq_sensor_state = "RQ_STATE_INIT"
    end

    return rq_sensor_state
  end

  def rq_ft_sensor_disconnected_warn_user():
    socket_open("127.0.0.1",29999,"SensorWarning")
    socket_send_string("popup FT Sensor must be connected to run this program.","SensorWarning")
    socket_send_byte(10,"SensorWarning")
    socket_close("SensorWarning")
  end

  def rq_ft_sensor_disconnected_stop_program():
    socket_open("127.0.0.1", 30002, "rq_ft_sensor_stop_socket")

    socket_send_string("def rq_ft_sensor_stop_program():", "rq_ft_sensor_stop_socket")
    socket_send_byte(10, "rq_ft_sensor_stop_socket")
    socket_send_string("  stopj(5.0)", "rq_ft_sensor_stop_socket")
    socket_send_byte(10, "rq_ft_sensor_stop_socket")
    socket_send_string("end", "rq_ft_sensor_stop_socket")
    socket_send_byte(10, "rq_ft_sensor_stop_socket")

    socket_close("rq_ft_sensor_stop_socket")
  end

  def rq_ft_sensor_disconnected_check():
    if rq_get_ft_sensor_state() == "RQ_STATE_INIT":
      rq_ft_sensor_disconnected_warn_user()
      rq_ft_sensor_disconnected_stop_program()
    end
  end

  #RTDE input registers
  TARGET_JOINT_0_INPUT_REGISTER_DOUBLE = 0
  TARGET_JOINT_1_INPUT_REGISTER_DOUBLE = 1
  TARGET_JOINT_2_INPUT_REGISTER_DOUBLE = 2
  TARGET_JOINT_3_INPUT_REGISTER_DOUBLE = 3
  TARGET_JOINT_4_INPUT_REGISTER_DOUBLE = 4
  TARGET_JOINT_5_INPUT_REGISTER_DOUBLE = 5
  FINISH_NODE_INPUT_REGISTER_INT32 = 0
  LICENSING_ERROR_INPUT_REGISTER_INT32 = 1
  ACTIVATION_NODE_COUNT_INPUT_REGISTER_INT32 = 2

  #RTDE output registers
  ACTIVE_NODE_OUTPUT_REGISTER_INT32 = 0
  NODE_EXECUTION_OUTPUT_COUNT_INT32 = 1
  ACTIVATION_NODE_COUNT_REGISTER_INT32 = 2
  TCP_FX_ACTUAL_OUTPUT_DOUBLE = 0
  TCP_FY_ACTUAL_OUTPUT_DOUBLE = 1
  TCP_FZ_ACTUAL_OUTPUT_DOUBLE = 2
  TCP_MX_ACTUAL_OUTPUT_DOUBLE = 3
  TCP_MY_ACTUAL_OUTPUT_DOUBLE = 4
  TCP_MZ_ACTUAL_OUTPUT_DOUBLE = 5
  GENERAL_OUTPUT_DOUBLE_6 = 6
  GENERAL_OUTPUT_DOUBLE_7 = 7
  GENERAL_OUTPUT_DOUBLE_8 = 8
  GENERAL_OUTPUT_DOUBLE_9 = 9
  GENERAL_OUTPUT_DOUBLE_10 = 10
  GENERAL_OUTPUT_DOUBLE_11 = 11

  write_output_integer_register(ACTIVE_NODE_OUTPUT_REGISTER_INT32, 0)
  write_output_integer_register(NODE_EXECUTION_OUTPUT_COUNT_INT32, 0)
  write_output_integer_register(ACTIVATION_NODE_COUNT_REGISTER_INT32, 0)
  write_output_float_register(TCP_FX_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_FY_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_FZ_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_MX_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_MY_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_MZ_ACTUAL_OUTPUT_DOUBLE, 0)

  global activation_node_count = 0
  global node_execution_count = 0

  def element_wise_subtract(l1, l2):
    global r = l1
    i=0
    while i<length(r):
      r[i]=l1[i]-l2[i]
      i=i+1
    end
    return r
  end

  def list_by_scalar_multiply(l1, scalar):
      global r = l1
      i=0
      while i<length(r):
        r[i]=l1[i]*scalar
        i=i+1
      end
      return r
   end

  def norm_inf(v):
    norm = 0
    i=0
    while i<length(v):
        n = norm(v[i])
        if(n > norm):
          norm = n
        end
      i=i+1
    end
    return norm
  end

  def active_and_reset_node(nodeId):
    server_activation_node_count = read_input_integer_register(ACTIVATION_NODE_COUNT_INPUT_REGISTER_INT32)

    activation_node_count = activation_node_count + 1
    node_execution_count = 0
    write_output_integer_register(NODE_EXECUTION_OUTPUT_COUNT_INT32, node_execution_count)
    rq_active_node = nodeId
    write_output_integer_register(ACTIVE_NODE_OUTPUT_REGISTER_INT32, nodeId)
    write_output_integer_register(ACTIVATION_NODE_COUNT_REGISTER_INT32, activation_node_count)

    while server_activation_node_count == read_input_integer_register(ACTIVATION_NODE_COUNT_INPUT_REGISTER_INT32):
      sync()
    end
  end

  def execute_node(nodeId):
    active_and_reset_node(nodeId)
    while not active_node_completed():
      sync()
    end
  end

  def initialise_execution_node():
    activation_node_count = 0
    node_execution_count = 0
    write_output_integer_register(ACTIVE_NODE_OUTPUT_REGISTER_INT32, 0)
    write_output_integer_register(ACTIVATION_NODE_COUNT_REGISTER_INT32, activation_node_count)
    write_output_integer_register(NODE_EXECUTION_OUTPUT_COUNT_INT32, node_execution_count)
    sync()
    succeeded = node_rpc_server.startnodeexecutor()
    if not succeeded:
      node_rpc_server.stopnodeexecutor()
      succeeded = node_rpc_server.startnodeexecutor()
      if not succeeded:
        popup("RTDE interface cannot initialize. Make sure that Ethernet/IP adapter and Profinet are disabled, and that no other URCaps use the RTDE interface.", "Robotiq Force Copilot", error=True)
        halt
      end
    end

    timer_thread = run rq_elapsed_timer_ms()
    sync()
    node_execution_initialized = False
    while (not node_execution_initialized) and (rq_elapsed_time < 100):
      node_execution_initialized = (read_input_integer_register(FINISH_NODE_INPUT_REGISTER_INT32) == -1)
      sync()
    end
    kill timer_thread

    if (not node_execution_initialized):
      popup("Node Execution initialization failed.", "Robotiq Force Copilot", error=True)
      halt
    end

  end

  thread execute_node_thread():
    joint_target_positions_prev = get_actual_joint_positions()
    servoj(joint_target_positions_prev)
    while True:
      joint_target_position = update_target_position()
      joint_target_distances = element_wise_subtract(joint_target_positions_prev, joint_target_position)
      max_joint_target_displacement = norm_inf(joint_target_distances)
      if max_joint_target_displacement > 0.2:
          textmsg("previous target position: ", joint_target_positions_prev)
          textmsg("next target position: ", joint_target_position)
          textmsg("max joint target displacement: ", max_joint_target_displacement)
          popup(max_joint_target_displacement, "Node Executor Error", False, True, True)
          halt
      end
      servoj(joint_target_position, t=0.008, lookahead_time=0.05, gain=500)
      joint_target_positions_prev = joint_target_position
    end
  end


  thread keep_node_executor_alive_thread():
    while True:
      rq_node_executor_thread_running = True
      sleep(0.0005)
    end
  end

  thread node_executor_manager_thread():
    while True:
      while not rq_node_executor_thread_running:
        sync()
      end
      node_executor_thread = run execute_node_thread()
      while rq_node_executor_thread_running:
        rq_node_executor_thread_running = False
        sleep(0.001)
      end
      kill node_executor_thread
    end
  end

  def active_node_completed():
    return (read_input_integer_register(ACTIVATION_NODE_COUNT_INPUT_REGISTER_INT32) == activation_node_count) and
           (read_input_integer_register(FINISH_NODE_INPUT_REGISTER_INT32) == rq_active_node)
  end

  def update_target_position():

    if read_input_integer_register(LICENSING_ERROR_INPUT_REGISTER_INT32):
        popup("License error!", "Robotiq Force Copilot", error=True)
        halt
    end

    joint_target_position = [0,0,0,0,0,0]
    joint_target_position[0] = read_input_float_register(TARGET_JOINT_0_INPUT_REGISTER_DOUBLE)
    joint_target_position[1] = read_input_float_register(TARGET_JOINT_1_INPUT_REGISTER_DOUBLE)
    joint_target_position[2] = read_input_float_register(TARGET_JOINT_2_INPUT_REGISTER_DOUBLE)
    joint_target_position[3] = read_input_float_register(TARGET_JOINT_3_INPUT_REGISTER_DOUBLE)
    joint_target_position[4] = read_input_float_register(TARGET_JOINT_4_INPUT_REGISTER_DOUBLE)
    joint_target_position[5] = read_input_float_register(TARGET_JOINT_5_INPUT_REGISTER_DOUBLE)

    node_execution_count = node_execution_count + 1
    write_output_integer_register(NODE_EXECUTION_OUTPUT_COUNT_INT32, node_execution_count)
    return joint_target_position
  end

  def set_servoj_node_cmd(q):
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_6, q[0])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_7, q[1])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_8, q[2])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_9, q[3])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_10, q[4])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_11, q[5])
  end

  def rq_collision_detection_start(force_limit = 140, torque_limit = 14, halt_on_collision = True):
    rq_force_protect_urcap = force_limit
    rq_torque_protect_urcap = torque_limit
    rq_collision_detection_active_time = 0.0
    rq_collision_detection_enabled = True
    rq_halt_on_collision_detection = halt_on_collision
  end

  def rq_collision_detection_stop():
    rq_collision_detection_enabled = False
  end

  def rq_on_collision_detection(message):
    textmsg("Collision Detection. " + message)
    popupTitle = "Collision Detection"
    if rq_halt_on_collision_detection:
      popup(message + " Program halt.", popupTitle, False, True, False)
      halt
    else:
      popup(message + " Program suspend.", popupTitle, True, False, False)
      socket_send_line("pause", "RQDashboardClient")
      rq_collision_detection_active_time = rq_controller_time_step
    end
  end

  ################################
  # MAIN
  ################################

  run read_force()
  run node_executor_manager_thread()

rtde_set_watchdog("external_force_torque", 5, "ignore")
enable_external_ft_sensor(False)
textmsg("disable external sensor")  
  #***********************************************************************************************
  # verify tap detection
  #***********************************************************************************************
  
  def rq_tap_count(forces, high_threshold):
  
    low_threshold = 2
    tapCount = 0
    lookingForPeak = True
    indexDown = 0
  
    i = 1
    lastIndex = length(forces) - 1
    while i <= lastIndex:
  
      deltaForce = forces[i] - forces[0]
  
     if lookingForPeak:
        if deltaForce >  high_threshold:
          lookingForPeak = False
        end
      else:
        if deltaForce < low_threshold:
          tapCount = tapCount + 1
          lookingForPeak = True
          indexDown = i
        end
      end
      i = i + 1
  
    end
  
    if indexDown != lastIndex:
      tapCount = 0
    end
  
    return tapCount
  
  end
  def shift_right(list, default_value = 0):
  
     i = length(list)-1
     while (i > 0):
        list[i]=list[i-1]
        i=i-1
     end
     list[0] = default_value
  
     return list
  end
  
  #***********************************************************************************************
  # Wait for force reached
  #***********************************************************************************************
  # desired_wrench : desired wrench
  # is_active      : list of 0 and 1, 1 : axis is controlled
  # feature        : 0:base, 1:tcp
  # timeout        : timeout in miliseconds
  #***********************************************************************************************
  def rq_wait_for_force_reached(desired_wrench, is_active, feature, timeout):
  
    feature_base = 0
    feature_tool = 1
    time_constant = 0.025
    alpha = 1 - pow(2.718, -1.0 * get_steptime() / time_constant)
  
    thresholds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    minimal_thresholds = [1.0, 1.0, 1.0, 0.1, 0.1, 0.1]
  
    applied_wrench = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    filtered_wrench = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  
    if (feature == feature_base):
      applied_wrench = list_by_scalar_multiply(base_wrench, -1.0)
    else:
      applied_wrench = list_by_scalar_multiply(tcp_wrench, -1.0)
    end
    filtered_wrench = applied_wrench
  
    i = 0
    while (i < 6):
      if (is_active[i]):
        thresholds[i] = 0.05 * norm(desired_wrench[i])
        if thresholds[i] < minimal_thresholds[i]:
          thresholds[i] = minimal_thresholds[i]
        end
      else:
        thresholds[i] = 10000
      end
      i = i+1
    end
  
   force_reached = False
  
   timer = 0
  
   while ((not force_reached) and (timer < timeout)):
  
      if (feature == feature_base):
         applied_wrench = list_by_scalar_multiply(base_wrench, -1.0)
      else:
         applied_wrench = list_by_scalar_multiply(tcp_wrench, -1.0)
      end
  
      i = 0
      while (i < 6):
        filtered_wrench[i] = (alpha * applied_wrench[i]) + ((1.0 - alpha) * filtered_wrench[i])
        i = i+1
      end
  
      force_reached = True
  
      i = 0
      while ((i < 6) and force_reached):
        error = norm(desired_wrench[i] - filtered_wrench[i])
        if (error > thresholds[i]):
          force_reached = False
        end
        i = i + 1
      end
  
      timer = timer + get_steptime()
  
      sync()
  
    end
  
    return force_reached
  end
  #***********************************************************************************************
  # verify click detection
  #***********************************************************************************************
  click_detection_children_ended = False
  
  def rq_click_detection(force_drop_threshold = 10, torque_drop_threshold = 1, force_radio_button_selected = True):
  
    current_norm = 0
    drop_threshold = 0
    norms = [0.0, 0.0, 0.0, 0.0, 0.0]
    click_detected = False
    wrench_indices = [0,0,0]
  
    if(force_radio_button_selected):
      drop_threshold = force_drop_threshold
      wrench_indices = [0,1,2]
    else:
      drop_threshold =torque_drop_threshold
      wrench_indices = [3,4,5]
    end
  
    while ((not click_detection_children_ended) and (not click_detected)):
  
      current_norm = norm([sensor_wrench[wrench_indices[0]], sensor_wrench[wrench_indices[1]], sensor_wrench[wrench_indices[2]]])
  
      norms[4] = norms[3]
      norms[3] = norms[2]
      norms[2] = norms[1]
      norms[1] = norms[0]
      norms[0] = current_norm
  
      avg_norm = (norms[2] + norms[3] + norms[4]) / 3.0
  
      #Check if clicking is detected with force
      norm_drop = avg_norm - current_norm
      if(norm_drop > drop_threshold):
        textmsg("Click detected")
        click_detected=True
      else:
        sleep(0.008)
      end
    end
  
    return click_detected
  end
  rq_ins_offset = p[0,0,0,0,0,0]
  rq_ins_start_pose = p[0,0,0,0,0,0]
  rq_actual_to_destination = p[0,0,0,0,0,0]
  rq_ins_destination =p[0,0,0,0,0,0]
  rq_ins_speed_setting = 0
  rq_rotation_not_completed = False
  rq_find_bottom_not_completed = False
  rq_spiral_not_completed = False
  
  def ins_actual_force_urcap(direction="X+"):
    axis = str_at(direction, 0)
    if (axis == "x") or (axis == "X"):
      return norm(get_applied_tcp_force(0))
    elif (axis == "y") or (axis == "Y"):
      return norm(get_applied_tcp_force(1))
    elif (axis == "z") or (axis == "Z"):
      return norm(get_applied_tcp_force(2))
    else:
      textmsg("ins_actual_force_urcap, invalid direction ", direction)
    end
  end
  
  def ins_actual_torque_urcap(direction = "Z+"):
    if (direction == "X+") or (direction == "X-") or (direction == "X"):
      return get_applied_tcp_force(3)
    elif (direction == "Y+") or (direction == "Y-") or (direction == "Y"):
      return get_applied_tcp_force(4)
    else:
      return get_applied_tcp_force(5)
    end
  
  end
  
  def rq_insert_spiral_urcap(direction="Z+",stop_force_threshold = 3, max_radius = 5.0, radius_incr=0.3, peck_mode = False, tangential_speed = 0.005):
  
    if (stop_force_threshold < 0) or (stop_force_threshold > 40):
      popup("stop_force_threshold parameter in Newton must be between 0 and 40","ERROR rq_insert_spiral_urcap")
      halt
    else:
      if (max_radius < 0.5) or (max_radius > 10):
        popup("max_radius parameter in mm must be between 0.5mm and 10mm","ERROR rq_insert_spiral_urcap")
        halt
      else:
        if (radius_incr < 0.01) or (radius_incr > 5.0):
        popup("radius_incr parameter in mm must be between 0.01mm and 5mm","ERROR rq_insert_spiral_urcap")
        halt
        else:
        rq_spiral_not_completed=False
        max_radius_set = max_radius / 1000
        ins_angle_incr=12.5
        radius_inc_set = radius_incr / 1000 / (360 / ins_angle_incr)
        ins_actual_radius=0.0001  #Start radius
  
        ins_x=0
        ins_y=0
        ins_z=0
        ins_pose=p[0,0,0,0,0,0]
        ins_current_pos=p[0,0,0,0,0,0]
        ins_actual_angle=0
        ins_search_result = False
        ins_radius_inc_per_deg=radius_inc_set/ins_angle_incr
        ins_PI=3.14159
        ins_arc_length=((ins_angle_incr*2*ins_PI*radius_inc_set)/360)*100
        ins_desired_arc_length = tangential_speed * rq_controller_time_step
  
        direction = ins_ucase_direction_urcap(direction)
  
        sync()
        #Find the bore of the part
        ins_current_pos=get_actual_tcp_pose()
        textmsg("Spiral search")
        sync()
  
        #********************************************************************************************************************
        #Spiral Search using any Axis
        #********************************************************************************************************************
        while ((ins_actual_radius <= max_radius_set) and (ins_actual_force_urcap(direction) >= stop_force_threshold)):
          #By default, the Spiral_Search function will maintain contact between both mating parts at all times
          if (peck_mode == False):
            #standard method
            #--------------------------------------------------------------------------------------------------------------------
            #For Spiral Search in the Z axis
            #--------------------------------------------------------------------------------------------------------------------
            if ((direction == "Z+") or (direction == "Z-")):
              ins_x=cos(d2r(ins_actual_angle))*ins_actual_radius
              ins_y=sin(d2r(ins_actual_angle))*ins_actual_radius
              ins_pose[0] = ins_x
              ins_pose[1] = ins_y
            #--------------------------------------------------------------------------------------------------------------------
            #For Spiral Search in the X axis
            #--------------------------------------------------------------------------------------------------------------------
            elif ((direction == "X+") or (direction == "X-")):
              ins_z=cos(d2r(ins_actual_angle))*ins_actual_radius
              ins_y=sin(d2r(ins_actual_angle))*ins_actual_radius
              ins_pose[2] = ins_z
              ins_pose[1] = ins_y
            #--------------------------------------------------------------------------------------------------------------------
            #For Spiral Search in the Y axis
            #--------------------------------------------------------------------------------------------------------------------
            elif ((direction == "Y+")or (direction == "Y-")):
              ins_x=cos(d2r(ins_actual_angle))*ins_actual_radius
              ins_z=sin(d2r(ins_actual_angle))*ins_actual_radius
              ins_pose[0] = ins_x
              ins_pose[2] = ins_z
            end
  
            ins_actual_angle = ins_actual_angle + (360 * ins_desired_arc_length) / (2 * ins_PI * ins_actual_radius)
  
            ins_actual_radius=ins_actual_angle*ins_radius_inc_per_deg
            next_pos=pose_trans(ins_current_pos,ins_pose)
  
            current_joint_pos=get_inverse_kin(next_pos)
            next_joint_pos=get_inverse_kin(next_pos)
            servoj(next_joint_pos,0.1, 0.1, rq_controller_time_step, 0.05, 500)
            #Operator enables "Peck Mode", the robot will retreat in the Z axis before moving to the next point
          else:
            #Fragile mode, the robot rises between each new point
            #Retreat from position
            if (direction == "Z+"):
              ins_pose[2]= -0.002
            elif (direction == "X+"):
              ins_pose[0]= -0.002
            elif (direction == "Y+"):
              ins_pose[1]= -0.002
            end
            if (direction == "Z-"):
              ins_pose[2]= 0.002
            elif (direction == "X-"):
              ins_pose[0]= 0.002
            elif (direction == "Y-"):
              ins_pose[1]= 0.002
            end
  
            next_pos=pose_trans(ins_current_pos,ins_pose)
            movej(next_pos)
            sleep(0.1)
            #move to a new coordinate
            #ins_actual_angle=ins_actual_angle+ins_angle_incr
            ins_desired_arc_length = 0.0005
            ins_actual_angle = ins_actual_angle + (360 * ins_desired_arc_length) / (2 * ins_PI * ins_actual_radius)
  
            if ((direction == "Z+") or (direction == "Z-")):
              ins_x=cos(d2r(ins_actual_angle))*ins_actual_radius
              ins_y=sin(d2r(ins_actual_angle))*ins_actual_radius
              ins_pose[0] = ins_x
              ins_pose[1] = ins_y
            elif ((direction == "X+") or (direction == "X-")):
              ins_z=cos(d2r(ins_actual_angle))*ins_actual_radius
              ins_y=sin(d2r(ins_actual_angle))*ins_actual_radius
              ins_pose[2] = ins_z
              ins_pose[1] = ins_y
            elif ((direction == "Y+") or (direction == "Y-")):
              ins_x=cos(d2r(ins_actual_angle))*ins_actual_radius
              ins_z=sin(d2r(ins_actual_angle))*ins_actual_radius
              ins_pose[0] = ins_x
              ins_pose[2] = ins_z
            end
            ins_actual_radius=ins_actual_angle*ins_radius_inc_per_deg
  
            next_pos=pose_trans(ins_current_pos,ins_pose)
            movej(next_pos)
            sleep(0.1)
            #Re-establish contact with the part
  
            if (direction == "Z+"):
              ins_pose[2]= 0.0005
            elif (direction == "X+"):
              ins_pose[0]= 0.0005
            elif (direction == "Y+"):
              ins_pose[1]= 0.0005
            end
             if (direction == "Z-"):
              ins_pose[2]= -0.0005
            elif (direction == "X-"):
              ins_pose[0]= -0.0005
            elif (direction == "Y-"):
              ins_pose[1]= -0.0005
            end
  
            next_pos=pose_trans(ins_current_pos,ins_pose)
            movel(next_pos, a=0.6, v=rq_ins_speed_setting)
            sleep(0.2)
          end
        end
        if (ins_actual_radius <= max_radius_set ):
          ins_search_result = True
          #Final Insert the Part into the bore#
          insertion_finish_move_urcap(direction)
        else:
          ins_search_result = False
          rq_spiral_not_completed = True
        end
        stopj(2)
        return ins_search_result
        end
      end
    end
  end
  
  def insertion_finish_move_urcap(direction = "Z+"):
    insertion_offset=p[0,0,0,0,0,0]
    current_pos=get_actual_tcp_pose()
    rq_actual_to_destination = pose_trans(pose_inv(current_pos), rq_ins_destination)
  
    axis = str_at(direction, 0)
    if axis == "X":
      insertion_offset=p[rq_actual_to_destination[0],0,0,0,0,0]
    elif axis == "Y":
      insertion_offset=p[0,rq_actual_to_destination[1],0,0,0,0]
    elif axis == "Z":
      insertion_offset=p[0,0,rq_actual_to_destination[2],0,0,0]
    else:
      textmsg("insertion_finish_move_urcap, invalid direction ", direction)
    end
    insertion_pose=pose_trans(current_pos, insertion_offset)
    movel(insertion_pose, a=0.05, v=rq_ins_speed_setting)
  end
  
  def rq_xor(a, b):
    return (a and not(b)) or (not(a) and b)
  end
  
  def rq_insert_rotation_urcap(clockwise_rotation_desired = True, direction="Z+", speed = 4.0, force_threshold=10, rotation_speed = 5, max_angle = 360, peck_mode = False, max_rotation_torque=1):
    if ((rotation_speed<=0) or (rotation_speed>60)):
      popup("rotation speed parameter in degrees / second must be between 0.01 and 60","ERROR rq_insert_rotation_urcap")
      halt
    else:
      if ((max_rotation_torque < 0.01) or (max_rotation_torque > 15)):
        popup("max_rotation_torque parameter in Newton-meter must be between 0.01 and 15","ERROR rq_insert_rotation_urcap")
        halt
      else:
        if ((max_angle<=1) or (max_angle > 360)):
          popup("max_angle parameter in degree must be between 1 and 360","ERROR rq_insert_rotation_urcap")
          halt
        else:
          rot_axe = 0
  
          direction = ins_ucase_direction_urcap(direction)
          rq_ins_start_pose = get_actual_tcp_pose()
          rq_actual_to_destination = pose_trans (pose_inv(rq_ins_start_pose),rq_ins_destination)
          direction = ins_ucase_direction_urcap(direction)
          if (direction == "X+") or (direction == "X-"):
            rq_ins_offset = p[rq_actual_to_destination[0],0,0,0,0,0]
          elif (direction == "Y+") or (direction == "Y-"):
            rq_ins_offset = p[0,rq_actual_to_destination[1],0,0,0,0]
          elif (direction == "Z+") or (direction == "Z-"):
            rq_ins_offset = p[0,0,rq_actual_to_destination[2],0,0,0]
          else:
            popup("direction parameter must be X+, X-, Y+, Y-, Z+ or Z-","ERROR rq_linear_search_urcap")
            halt
          end
          if (direction == "X+")  or (direction == "X-"):
            rot_axe = 3
            lin_axe = 0
            distance_to_reach = rq_actual_to_destination[0]
          elif (direction == "Y+")  or (direction == "Y-") :
            rot_axe = 4
            lin_axe = 1
            distance_to_reach = rq_actual_to_destination[1]
          elif (direction == "Z+") or (direction == "Z-") :
            rot_axe = 5
            lin_axe = 2
            distance_to_reach = rq_actual_to_destination[2]
          else:
            popup("direction parameter must be X+, X-, Y+, Y-, Z+ or Z-","ERROR rq_insert_rotation_urcap")
            halt
          end
          rot_direction_sign = 1
          if ((direction == "Z-") or (direction == "X-") or (direction == "Y-")):
            rot_direction_sign=-1
          end
          rq_ins_speed_setting = speed/1000
          rq_rotation_not_completed = False
          posrot=p[0,0,0,0,0,0]
          maxRotation=d2r(max_angle)
          rot_step = d2r(rotation_speed) * rq_controller_time_step * rot_direction_sign
          line_step = rq_ins_speed_setting * rq_controller_time_step * rot_direction_sign
          rot_actual_angle = 0
          rot_actual_mode = 1 #1= linear, 2 = rotation
          rot_actual_distance = 0
          pos_circle=get_actual_tcp_pose()
  
          if (peck_mode == False):
            while ((norm(rot_actual_distance) <= norm(distance_to_reach)) and (norm(rot_actual_angle) <= maxRotation)):
              clockwise_rotation_computed = clockwise_rotation_desired
              if(norm(ins_actual_torque_urcap(direction)) > max_rotation_torque):
                clockwise_rotation_computed = rq_xor((rot_direction_sign == 1), (rot_actual_angle > 0))
              end
              if (ins_actual_force_urcap(direction) >= force_threshold):
                if (rot_actual_mode==1):
                  stopj(2)
                  rot_actual_distance = rot_actual_distance - line_step
                  posrot[lin_axe]=rot_actual_distance
                end
                rot_actual_angle = compute_rotation_next_angle(clockwise_rotation_desired, clockwise_rotation_computed, rot_actual_angle, rot_step)
                posrot[rot_axe]=rot_actual_angle
                rot_actual_mode = 2
              else:
                rot_actual_distance = rot_actual_distance + line_step
                posrot[lin_axe]=rot_actual_distance
                rot_actual_mode = 1
              end
              next_pos=pose_trans(pos_circle,posrot)
              next_joint_pos=get_inverse_kin(next_pos)
              servoj(next_joint_pos,0.1, 0.1, rq_controller_time_step, 0.05, 500)
            end
            stopj(2)
          else:
            #peck mode
            clockwise_rotation_computed = clockwise_rotation_desired
            while ((norm(rot_actual_distance) <= norm(distance_to_reach)) and (norm(rot_actual_angle) <= maxRotation)):
              if (ins_actual_force_urcap(direction) >= force_threshold):
                #goes up
                posrot[lin_axe]= rot_actual_distance - 0.002
                next_pos=pose_trans(pos_circle, posrot)
                movej(next_pos)
  
                #rotate
                step = 0.01*rotation_speed
                rot_actual_angle = compute_rotation_next_angle(clockwise_rotation_desired, clockwise_rotation_computed, posrot[rot_axe], step)
                posrot[rot_axe]=rot_actual_angle
                next_pos=pose_trans(pos_circle, posrot)
                movej(next_pos)
  
                #go back in touch with the part
                posrot[lin_axe]= rot_actual_distance
                next_pos=pose_trans(pos_circle, posrot)
                movej(next_pos)
                sleep(0.1)
  
                rot_actual_angle = posrot[rot_axe]
              else:
                rot_actual_distance = rot_actual_distance + line_step
                posrot[lin_axe]=rot_actual_distance
  
                next_pos=pose_trans(pos_circle, posrot)
                next_joint_pos=get_inverse_kin(next_pos)
                servoj(next_joint_pos, 0.1, 0.1, rq_controller_time_step, 0.05, 500)
              end
            end
          end
  
          if(norm(rot_actual_angle) <= maxRotation):
            rq_rotation_not_completed=False
  	      else:
            rq_rotation_not_completed=True
          end
        end
      end
    end
    return rq_rotation_not_completed
  end
  
  def ins_ucase_direction_urcap(direction):
    if (direction == "z+") or (direction == "Z+"):
      ins_ucase_result = "Z+"
    elif (direction == "x+") or (direction == "X+"):
      ins_ucase_result = "X+"
    elif (direction == "y+") or (direction == "Y+"):
      ins_ucase_result ="Y+"
    elif (direction == "z-") or (direction == "Z-"):
      ins_ucase_result = "Z-"
    elif (direction == "x-") or (direction == "X-"):
      ins_ucase_result = "X-"
    elif (direction == "y-") or (direction == "Y-"):
      ins_ucase_result ="Y-"
    else:
      popup("direction parameter must be X+, X-, Y+, Y-, Z+ or Z-","ERROR Insertion")
      halt
    end
    return ins_ucase_result
  end
  
  def compute_rotation_next_angle(is_clockwise_desired, is_clockwise_measured, current_angle, step):
    if (is_clockwise_desired):
      if (is_clockwise_measured):
        new_angle = current_angle + step
      else:
        new_angle = current_angle - (step/2)
      end
    else:
      if (is_clockwise_measured):
        new_angle = current_angle + (step/2)
      else:
        new_angle = current_angle - step
      end
    end
    return new_angle
  end
  #************************************************
  #Function:  rq_linear_search_urcap(direction="Z+", force[N] = 10, speed[m/s] = 0.004, max_distance[m] = 0.02)
  #   Find a specific force in the direction of "direction".
  #   Robot will move towards a max_distance from the current position in the tool frame
  #   Return True if the force is detected during the robot motion
  #
  #************************************************
  def rq_linear_search_urcap(direction="Z+", force_threshold = 10, speed = 0.004, max_distance = 0.02, feature = 0 ):
  
    if (max_distance > 2.0):
      popup("maximum distance parameter in meters must be between 0 and 2.0","ERROR rq_linear_search_urcap")
      halt
    elif (speed < 0.0001) or (speed > 0.15):
      popup("speed parameter in mm/s must be between 0.1 and 150","ERROR rq_linear_search_urcap")
      halt
    elif (force_threshold < 0.0) or (force_threshold > 200):
      popup("Force parameter in Newtons must be between 0 and 200","ERROR rq_linear_search_urcap")
      halt
    elif (feature != 0) and (feature != 1):
      popup("feature value should be 0 for base or 1 for tool","ERROR rq_linear_search_urcap")
      halt
    end
  
    feature_base = 0
    feature_tool = 1
    steptime = get_steptime()
    force_index = 0
  
    axis = str_at(direction, 0)
    sign = str_at(direction, 1)
  
    direction_sign = 1
    if sign == "-":
      direction_sign = -1
      max_distance = max_distance * direction_sign
    end
  
    pose_offset = p[0,0,0,0,0,0]
    if (axis == "X") or (axis == "x"):
      pose_offset = p[max_distance,0,0,0,0,0]
      force_index = 0
    elif (axis == "Y") or (axis == "y"):
      pose_offset = p[0,max_distance,0,0,0,0]
      force_index = 1
    elif (axis == "Z") or (axis == "z"):
      pose_offset = p[0,0,max_distance,0,0,0]
      force_index = 2
    else:
      popup("direction parameter must be X+, X-, Y+, Y-, Z+ or Z-","ERROR rq_linear_search_urcap")
      halt
    end
  
    pose_from = get_actual_tcp_pose()
    pose_to = pose_from
    if feature == feature_base:
      pose_to = pose_add(pose_from, pose_offset)
    elif feature == feature_tool:
      pose_to = pose_trans(pose_from, pose_offset)
    end
  
    distance = point_dist(pose_from, pose_to)
    number_pose_interpolate = floor(distance / (speed * steptime)) + 1
    delta_alpha = 1.0 / number_pose_interpolate
  
    alpha = 0.0
    local surface_found = False
  
    while (alpha <= 1.0) and (not surface_found):
      alpha = alpha + delta_alpha
      pose_interpolate = interpolate_pose(pose_from, pose_to, alpha)
      servoj(get_inverse_kin(pose_interpolate), 0.1, 0.1, steptime, 0.05, 500)
  
      force = 0
      if feature == feature_base:
        force = get_applied_base_force(force_index)
      elif feature == feature_tool:
        force = get_applied_tcp_force(force_index)
      end
  
      if (direction_sign * force) >= force_threshold:
        surface_found = True
      end
    end
  
    return surface_found
  
  end
    global servojId = 2
  rq_collision_detection_stop()
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq_Grippers, 1.5.2, Robotiq Inc.
  #   Type: Gripper
  #aliases for the gripper variable names
  ACT = 1
  GTO = 2
  ATR = 3
  ARD = 4
  FOR = 5
  SPE = 6
  OBJ = 7
  STA = 8
  FLT = 9
  POS = 10
  PRE = 11
  LBP = 12
  LRD = 13
  LBL = 14
  LGN = 15
  MSC = 16
  
  gripper_1_connected = False
  gripper_2_connected = False
  gripper_3_connected = False
  gripper_4_connected = False
  
  gripper_1_socket_open = False
  gripper_2_socket_open = False
  gripper_3_socket_open = False
  gripper_4_socket_open = False
  
  def rq_init_comm_if_connected(gripper_sid=9, gripper_socket="1"):
      if(not is_gripper_socket_open(gripper_socket)):
        open_gripper_socket(gripper_socket)
      end
  
      is_gripper_connected = rq_is_gripper_connected(gripper_sid, gripper_socket)
      if(is_gripper_connected):
          rq_set_gripper_connected(gripper_socket)
      end
  
      return is_gripper_connected
  end
  
  def open_gripper_socket(gripper_socket):
    is_open = socket_open("127.0.0.1",63352, gripper_socket)
    set_gripper_socket_open(gripper_socket, is_open)
  end
  
  def is_gripper_socket_open(gripper_socket):
    if(gripper_socket == "1"):
      return gripper_1_socket_open
    elif(gripper_socket == "2"):
      return gripper_2_socket_open
    elif(gripper_socket == "3"):
      return gripper_3_socket_open
    elif(gripper_socket == "4"):
      return gripper_4_socket_open
    else:
      return False
    end
  end
  
  def set_gripper_socket_open(gripper_socket, is_open):
    if(gripper_socket == "1"):
      gripper_1_socket_open = is_open
    elif(gripper_socket == "2"):
      gripper_2_socket_open = is_open
    elif(gripper_socket == "3"):
      gripper_3_socket_open = is_open
    elif(gripper_socket == "4"):
      gripper_4_socket_open = is_open
    else:
    end
  end
  
  def rq_is_gripper_connected(gripper_sid=9, gripper_socket="1"):
      socket_set_var("SID", gripper_sid,  gripper_socket)
      ack = socket_read_byte_list(3, gripper_socket, 0.1)
      return is_ack(ack)
  end
  
  def rq_set_gripper_connected(gripper_id="1"):
      if(gripper_id == "1"):
          gripper_1_connected = True
      end
  
      if (gripper_id == "2"):
          gripper_2_connected = True
      end
  
      if (gripper_id == "3"):
          gripper_3_connected = True
      end
  
      if (gripper_id == "4"):
          gripper_4_connected = True
      end
  end
  
  def rq_wait_for_gripper_connected():
      gripper_socket = "gripper_conn_socket"
      socket_open("127.0.0.1",63352, gripper_socket)
  
      retryCtr = 1
      sid_list = rq_get_sid(gripper_socket)
      gripper_is_connected = rq_is_any_gripper_connected(sid_list)
  
      while(not gripper_is_connected and retryCtr < 2000):
          retryCtr = retryCtr + 1
          sid_list = rq_get_sid(gripper_socket)
          gripper_is_connected = rq_is_any_gripper_connected(sid_list)
      end
  
      socket_close(gripper_socket)
  end
  
  def rq_is_any_gripper_connected(sid_list):
      is_gripper_1_connected = rq_is_gripper1_in_sid_list(sid_list)
      is_gripper_2_connected = rq_is_gripper2_in_sid_list(sid_list)
      is_gripper_3_connected = rq_is_gripper3_in_sid_list(sid_list)
      is_gripper_4_connected = rq_is_gripper4_in_sid_list(sid_list)
  
      if(is_gripper_1_connected or is_gripper_2_connected or is_gripper_3_connected or is_gripper_4_connected):
          return True
      else:
          return False
      end
  end
  
  def rq_is_gripper_in_sid_list(gripper_sid, sid_list):
      sid_list_length = sid_list[0]
      sid_list_empty_length = 2
  
      if (sid_list_length <= sid_list_empty_length):
          return False
      end
  
      sid1 = sid_list[2]
      sid2 = sid_list[5]
      sid3 = sid_list[8]
      sid4 = sid_list[11]
  
      if(sid1 == gripper_sid or sid2 == gripper_sid or sid3 == gripper_sid or sid4 == gripper_sid):
          return True
      else:
          return False
      end
  end
  
  def rq_is_gripper1_in_sid_list(sid_list):
      gripper_1_sid_ascii = 57
      return rq_is_gripper_in_sid_list(gripper_1_sid_ascii, sid_list)
  end
  
  def rq_is_gripper2_in_sid_list(sid_list):
      gripper_2_sid_ascii = 50
      return rq_is_gripper_in_sid_list(gripper_2_sid_ascii, sid_list)
  end
  
  def rq_is_gripper3_in_sid_list(sid_list):
      gripper_3_sid_ascii = 51
      return rq_is_gripper_in_sid_list(gripper_3_sid_ascii, sid_list)
  end
  
  def rq_is_gripper4_in_sid_list(sid_list):
      gripper_4_sid_ascii = 52
      return rq_is_gripper_in_sid_list(gripper_4_sid_ascii, sid_list)
  end
  
  def rq_set_sid(gripper_sid=9, gripper_socket="1"):
      socket_set_var("SID", gripper_sid,  gripper_socket)
      sync()
      ack = socket_read_byte_list(3, gripper_socket)
      return is_ack(ack)
  end
  
  def rq_get_sid(gripper_socket="1"):
      socket_send_string("GET SID", gripper_socket)
      sync()
      sid_list = socket_read_byte_list(17, gripper_socket)
      sync()
      return sid_list
  end
  
  def rq_activate(gripper_socket="1"):
      rq_gripper_act = 0
  
      if (not rq_is_gripper_activated(gripper_socket)):
         rq_reset(gripper_socket)
  
         while(socket_get_var("ACT",gripper_socket) == 1):
            sleep(0.1)
            rq_reset(gripper_socket)
         end
      end
  
      rq_set_var(ACT,1, gripper_socket)
  end
  
  def rq_activate_and_wait(gripper_socket="1"):
      rq_activate(gripper_socket)
      sleep(1.0)
  
      while(not rq_is_gripper_activated(gripper_socket)):
          # wait for activation completed
      end
      sleep(0.5)
  end
  
  def rq_activate_all_grippers(reset=False):
      if(gripper_1_connected):
          rq_reset_and_activate("1", reset)
      end
  
      if(gripper_2_connected):
          rq_reset_and_activate("2", reset)
      end
  
      if(gripper_3_connected):
          rq_reset_and_activate("3", reset)
      end
  
      if(gripper_4_connected):
          rq_reset_and_activate("4", reset)
      end
  
      sleep(0.2)
  end
  
  def rq_reset_and_activate(gripper_socket="1", reset=False):
      if(reset):
          rq_reset(gripper_socket)
          sleep(0.5)
          rq_activate_and_wait(gripper_socket)
      elif(not rq_is_gripper_activated(gripper_socket)):
          rq_activate_and_wait(gripper_socket)
      end
  end
  
  def rq_scan_block():
      gripper_socket = "scn_block_socket"
      socket_open("127.0.0.1", 63352, gripper_socket)
      socket_set_var("SCN_BLOCK", 1, gripper_socket)
      sync()
      ack_test = socket_read_byte_list(3, gripper_socket)
  
      retry_counter = 0
  
      while(not is_ack(ack_test) and retry_counter < 5):
          socket_set_var("SCN_BLOCK", 1, gripper_socket)
          sync()
          ack_test = socket_read_byte_list(3, gripper_socket)
          retry_counter = retry_counter + 1
      end
  
      socket_close("scn_block_socket")
  end
  
  def rq_stop(gripper_socket="1"):
      rq_set_var(GTO,0, gripper_socket)
  end
  
  def rq_reset(gripper_socket="1"):
      rq_gripper_act = 0
      rq_obj_detect = 0
      rq_mov_complete = 0
  
      rq_set_var(ACT,0, gripper_socket)
      rq_set_var(ATR,0, gripper_socket)
  end
  
  def rq_auto_release_open_and_wait(gripper_socket="1"):
      rq_set_var(ARD,0, gripper_socket)
      rq_set_var(ACT,1, gripper_socket)
      rq_set_var(ATR,0, gripper_socket)
      sleep(0.1)
      rq_set_var(ATR,1, gripper_socket)
  
      rq_wait_autorelease_completed(gripper_socket)
  end
  
  def rq_auto_release_close_and_wait(gripper_socket="1"):
      rq_set_var(ARD,1, gripper_socket)
      rq_set_var(ACT,1, gripper_socket)
      rq_set_var(ATR,0, gripper_socket)
      sleep(0.1)
      rq_set_var(ATR,1, gripper_socket)
  
      rq_wait_autorelease_completed(gripper_socket)
  end
  
  def rq_wait_autorelease_completed(gripper_socket="1"):
      retryCounter = 1
      gFLT = rq_get_var(FLT, 2, gripper_socket)
  
      while(not is_FLT_autorelease_in_progress(gFLT) and retryCounter <= 20):
          retryCounter = retryCounter + 1
          gFLT = rq_get_var(FLT, 2, gripper_socket)
          sleep(0.1)
      end
  
      retryCounter = 1
      gFLT = rq_get_var(FLT, 2, gripper_socket)
  
      while(not is_FLT_autorelease_completed(gFLT) and retryCounter <= 100):
          retryCounter = retryCounter + 1
          gFLT = rq_get_var(FLT, 2, gripper_socket)
          sleep(0.1)
      end
  end
  
  def rq_set_force(force, gripper_socket="1"):
      rq_set_var(FOR,force, gripper_socket)
  end
  
  def rq_set_speed(speed, gripper_socket="1"):
      rq_set_var(SPE,speed, gripper_socket)
  end
  
  def rq_open(gripper_socket="1"):
      rq_move(0, gripper_socket)
  end
  
  def rq_close(gripper_socket="1"):
      rq_move(255, gripper_socket)
  end
  
  def rq_open_and_wait(gripper_socket="1"):
      rq_move_and_wait(0, gripper_socket)
  end
  
  def rq_close_and_wait(gripper_socket="1"):
      rq_move_and_wait(255, gripper_socket)
  end
  
  def rq_move(pos, gripper_socket="1"):
      rq_mov_complete = 0
      rq_obj_detect = 0
  
      rq_set_pos(pos, gripper_socket)
      rq_go_to(gripper_socket)
  end
  
  def rq_move_and_wait(pos, gripper_socket="1"):
      rq_move(pos, gripper_socket)
  
      while (not rq_is_motion_complete(gripper_socket)):
          # wait for motion completed
          sleep(0.01)
          sync()
      end
  
      # following code used for compatibility with previous versions
      rq_is_object_detected(gripper_socket)
  
      if (rq_obj_detect != 1):
          rq_mov_complete = 1
      end
  end
  
  def rq_wait_for_pos_request(pos, gripper_socket="1"):
      gPRE = rq_get_var(PRE, 3, gripper_socket)
      pre = (gPRE[1] - 48)*100 + (gPRE[2] -48)*10 + gPRE[3] - 48
  
      while (pre != pos):
          rq_set_var(POS, pos, gripper_socket)
          gPRE = rq_get_var(PRE, 3, gripper_socket)
          pre = (gPRE[1] - 48)*100 + (gPRE[2] -48)*10 + gPRE[3] - 48
          sync()
          rq_go_to(gripper_socket)
      end
  end
  
  def rq_wait_for_pos(pos, gripper_socket="1"):
      rq_wait_for_pos_request(pos, gripper_socket)
  
      # Wait for the gripper motion to complete
      while (not rq_is_motion_complete(gripper_socket)):
          # wait for motion completed
          sleep(0.01)
          sync()
          rq_go_to(gripper_socket)
      end
  
      # following code used for compatibility with previous versions
      rq_is_object_detected(gripper_socket)
  
      if (rq_obj_detect != 1):
          rq_mov_complete = 1
      end
  end
  
  def rq_wait(gripper_socket="1"):
      # Wait for the gripper motion to complete
      while (not rq_is_motion_complete(gripper_socket)):
          # wait for motion completed
          sleep(0.01)
          sync()
      end
  
      # following code used for compatibility with previous versions
      rq_is_object_detected(gripper_socket)
  
      if (rq_obj_detect != 1):
          rq_mov_complete = 1
      end
  end
  
  def rq_wait_for_object_detected(gripper_socket="1"):
      # Wait the object detection
      while (not rq_is_object_detected(gripper_socket)):
          # wait for motion completed
          sleep(0.01)
          sync()
      end
  end
  
  def rq_go_to(gripper_socket="1"):
      rq_set_var(GTO,1, gripper_socket)
  end
  
  # set the position
  def rq_set_pos(pos, gripper_socket="1"):
      rq_set_var(POS, pos, gripper_socket)
  
      gPRE = rq_get_var(PRE, 3, gripper_socket)
      pre = (gPRE[1] - 48)*100 + (gPRE[2] -48)*10 + gPRE[3] - 48
  
      while (pre != pos):
          rq_set_var(POS, pos, gripper_socket)
          gPRE = rq_get_var(PRE, 3, gripper_socket)
          pre = (gPRE[1] - 48)*100 + (gPRE[2] -48)*10 + gPRE[3] - 48
          sync()
      end
  end
  
  # set the position, speed and force
  def rq_set_pos_spd_for(pos, speed, force, gripper_socket="1"):
      rq_send_pos_spd_for(pos, speed, force, gripper_socket)
  
      enter_critical
      ack = socket_read_byte_list(3, gripper_socket)
      exit_critical
  
      sync()
  
      while(is_not_ack(ack)):
          rq_send_pos_spd_for(pos, speed, force, gripper_socket)
  
          enter_critical
          ack = socket_read_byte_list(3, gripper_socket)
          exit_critical
  
          sync()
      end
  
      gPRE = rq_get_var(PRE, 3, gripper_socket)
      pre = (gPRE[1] - 48)*100 + (gPRE[2] -48)*10 + gPRE[3] - 48
  
      while (pre != pos):
          rq_set_var(POS, pos, gripper_socket)
          gPRE = rq_get_var(PRE, 3, gripper_socket)
          pre = (gPRE[1] - 48)*100 + (gPRE[2] -48)*10 + gPRE[3] - 48
          sync()
      end
  
      rq_wait_for_pos_request(pos, gripper_socket)
  end
  
  def rq_set_gripper_max_current_mA(current_mA, gripper_socket="1"):
      current = floor(current_mA / 10)
      rq_set_var(MSC, current, gripper_socket)
      sleep(1.5)
  end
  
  def rq_set_gripper_max_cur(current_mA, gripper_socket="1"):
      rq_set_gripper_max_current_mA(current_mA, gripper_socket)
  end
  
  def rq_get_gripper_max_current_mA(gripper_socket="1"):
      socket_send_string("GET MSC",gripper_socket)
      sync()
      var_value = socket_read_byte_list(3, gripper_socket)
  
      current = rq_list_of_bytes_to_value(var_value)
  
      if(current == -1):
          current_mA = current
      else:
          current_mA = current * 10
      end
  
      return current_mA
  end
  
  def rq_get_gripper_max_cur(gripper_socket="1"):
      return rq_get_gripper_max_current_mA(gripper_socket)
  end
  
  def rq_list_of_bytes_to_value(list_of_bytes):
      value = -1
  
      # response list length
      if (list_of_bytes[0] == 1):
          value = list_of_bytes[1] - 48
      elif (list_of_bytes[0] == 2):
          value = (list_of_bytes[1] - 48) * 10 + (list_of_bytes[2] - 48)
      elif (list_of_bytes[0] == 3):
          value = (list_of_bytes[1] - 48) * 100 + (list_of_bytes[2] - 48) * 10 + (list_of_bytes[3] - 48)
      end
  
      return value
  end
  
  # send the position, speed and force
  def rq_send_pos_spd_for(pos, speed, force, gripper_socket="1"):
      enter_critical
  
      socket_send_string("SET POS", gripper_socket)
      socket_send_byte(32, gripper_socket)
      socket_send_string(pos, gripper_socket)
      socket_send_byte(32, gripper_socket)
      socket_send_string("SPE", gripper_socket)
      socket_send_byte(32, gripper_socket)
      socket_send_string(speed, gripper_socket)
      socket_send_byte(32, gripper_socket)
      socket_send_string("FOR", gripper_socket)
      socket_send_byte(32, gripper_socket)
      socket_send_string(force, gripper_socket)
      socket_send_byte(10, gripper_socket)
  
      exit_critical
  
      sync()
  end
  
  def rq_is_motion_complete(gripper_socket="1"):
      rq_mov_complete = 0
  
      gOBJ = rq_get_var(OBJ, 1, gripper_socket)
      sleep(0.01)
  
      if (is_OBJ_gripper_at_position(gOBJ)):
          rq_mov_complete = 1
          return True
      end
  
      if (is_OBJ_object_detected(gOBJ)):
          rq_mov_complete = 1
          return True
      end
  
      return False
  
  end
  
  def rq_is_gripper_activated(gripper_socket="1"):
      gSTA = rq_get_var(STA, 1, gripper_socket)
  
      if(is_STA_gripper_activated(gSTA)):
          rq_gripper_act = 1
          return True
      else:
          rq_gripper_act = 0
          return False
      end
  end
  
  def rq_is_object_detected(gripper_socket="1"):
      gOBJ = rq_get_var(OBJ, 1, gripper_socket)
  
      if(is_OBJ_object_detected(gOBJ)):
          rq_obj_detect = 1
          return True
      else:
          rq_obj_detect = 0
          return False
      end
  end
  
  def rq_current_pos(gripper_socket="1"):
      enter_critical
      rq_pos = socket_get_var("POS",gripper_socket)
      exit_critical
      sync()
      return rq_pos
  end
  
  def rq_motor_current(gripper_socket="1"):
      enter_critical
      rq_current = socket_get_var("COU",gripper_socket)
      exit_critical
      sync()
      return rq_current * 10
  end
  
  def rq_print_connected_grippers():
      if(gripper_1_connected):
          textmsg("Gripper 1 : ", "connected and socket open.")
      end
  
      if (gripper_2_connected):
          textmsg("Gripper 2 : ", "connected and socket open.")
      end
  
      if (gripper_3_connected):
          textmsg("Gripper 3 : ", "connected and socket open.")
      end
  
      if (gripper_4_connected):
          textmsg("Gripper 4 : ", "connected and socket open.")
      end
  end
  
  def rq_print_gripper_fault_code(gripper_socket="1"):
      gFLT = rq_get_var(FLT, 2, gripper_socket)
  
      if(is_FLT_no_fault(gFLT)):
          textmsg("Gripper Fault : ", "No Fault (0x00)")
      elif (is_FLT_action_delayed(gFLT)):
          textmsg("Gripper Fault : ", "Priority Fault: Action delayed, initialization must be completed prior to action (0x05)")
      elif (is_FLT_not_activated(gFLT)):
          textmsg("Gripper Fault : ", "Priority Fault: The activation must be set prior to action (0x07)")
      elif (is_FLT_autorelease_in_progress(gFLT)):
          textmsg("Gripper Fault : ", "Minor Fault: Automatic release in progress (0x0B)")
      elif (is_FLT_overcurrent(gFLT)):
          textmsg("Gripper Fault : ", "Minor Fault: Overcurrent protection triggered (0x0E)")
      elif (is_FLT_autorelease_completed(gFLT)):
          textmsg("Gripper Fault : ", "Major Fault: Automatic release completed (0x0F)")
      else:
          textmsg("Gripper Fault : ", "Unknown Fault")
      end
  end
  
  def rq_print_gripper_num_cycles(gripper_socket="1"):
      socket_send_string("GET NCY",gripper_socket)
      sync()
      string_from_server = socket_read_string(gripper_socket)
      sync()
  
      if(string_from_server == "0"):
          textmsg("Gripper Cycle Number : ", "Number of cycles is unreachable.")
      else:
          textmsg("Gripper Cycle Number : ", string_from_server)
      end
  end
  
  def rq_print_gripper_driver_state(gripper_socket="1"):
      socket_send_string("GET DST",gripper_socket)
      sync()
      string_from_server = socket_read_string(gripper_socket)
      sync()
  
      if(string_from_server == "0"):
          textmsg("Gripper Driver State : ", "RQ_STATE_INIT")
      elif(string_from_server == "1"):
          textmsg("Gripper Driver State : ", "RQ_STATE_LISTEN")
      elif(string_from_server == "2"):
          textmsg("Gripper Driver State : ", "RQ_STATE_READ_INFO")
      elif(string_from_server == "3"):
          textmsg("Gripper Driver State : ", "RQ_STATE_ACTIVATION")
      else:
          textmsg("Gripper Driver State : ", "RQ_STATE_RUN")
      end
  end
  
  def rq_print_gripper_serial_number(gripper_socket="1"):
      socket_send_string("GET SNU",gripper_socket)
      sync()
      string_from_server = socket_read_string(gripper_socket)
      sync()
      textmsg("Gripper Serial Number : ", string_from_server)
  end
  
  def rq_print_gripper_firmware_version(gripper_socket="1"):
      socket_send_string("GET FWV",gripper_socket)
      sync()
      string_from_server = socket_read_string(gripper_socket)
      sync()
      textmsg("Gripper Firmware Version : ", string_from_server)
  end
  
  def rq_print_gripper_driver_version(gripper_socket="1"):
      socket_send_string("GET VER",gripper_socket)
      sync()
      string_from_server = socket_read_string(gripper_socket)
      sync()
      textmsg("Gripper Driver Version : ", string_from_server)
  end
  
  def rq_print_gripper_probleme_connection(gripper_socket="1"):
      socket_send_string("GET PCO",gripper_socket)
      sync()
      string_from_server = socket_read_string(gripper_socket)
      sync()
      if (string_from_server == "0"):
          textmsg("Gripper Connection State : ", "No connection problem detected")
      else:
          textmsg("Gripper Connection State : ", "Connection problem detected")
      end
  end
  
  # Returns True if list_of_bytes is [3, 'a', 'c', 'k']
  def is_ack(list_of_bytes):
  
      # list length is not 3
      if (list_of_bytes[0] != 3):
          return False
      end
  
      # first byte not is 'a'?
      if (list_of_bytes[1] != 97):
          return False
      end
  
      # first byte not is 'c'?
      if (list_of_bytes[2] != 99):
          return False
      end
  
      # first byte not is 'k'?
      if (list_of_bytes[3] != 107):
          return False
      end
  
      return True
  end
  
  # Returns True if list_of_bytes is not [3, 'a', 'c', 'k']
  def is_not_ack(list_of_bytes):
      if (is_ack(list_of_bytes)):
          return False
      else:
          return True
      end
  end
  
  def is_STA_gripper_activated (list_of_bytes):
  
      # list length is not 1
      if (list_of_bytes[0] != 1):
          return False
      end
  
      # byte is '3'?
      if (list_of_bytes[1] == 51):
          return True
      end
  
      return False
  end
  
  # Returns True if list_of_byte is [1, '1'] or [1, '2']
  # Used to test OBJ = 0x1 or OBJ = 0x2
  def is_OBJ_object_detected (list_of_bytes):
  
      # list length is not 1
      if (list_of_bytes[0] != 1):
          return False
      end
  
      # byte is '2'?
      if (list_of_bytes[1] == 50):
          return True
      end
  
      # byte is '1'?
      if (list_of_bytes[1]  == 49):
          return True
      end
  
      return False
  
  end
  
  # Returns True if list_of_byte is [1, '3']
  # Used to test OBJ = 0x3
  def is_OBJ_gripper_at_position (list_of_bytes):
  
      # list length is not 1
      if (list_of_bytes[0] != 1):
          return False
      end
  
      # byte is '3'?
      if (list_of_bytes[1] == 51):
          return True
      end
  
      return False
  end
  
  def is_not_OBJ_gripper_at_position (list_of_bytes):
  
      if (is_OBJ_gripper_at_position(list_of_bytes)):
          return False
      else:
          return True
      end
  end
  
  def is_FLT_no_fault(list_of_bytes):
  
      # list length is not 2
      if (list_of_bytes[0] != 2):
          return False
      end
  
      # first byte is '0'?
      if (list_of_bytes[1] != 48):
          return False
      end
  
      # second byte is '0'?
      if (list_of_bytes[2] != 48):
          return False
      end
  
      return True
  
  end
  
  def is_FLT_action_delayed(list_of_bytes):
  
      # list length is not 2
      if (list_of_bytes[0] != 2):
          return False
      end
  
      # first byte is '0'?
      if (list_of_bytes[1] != 48):
          return False
      end
  
      # second byte is '5'?
      if (list_of_bytes[2] != 53):
          return False
      end
  
      return True
  end
  
  def is_FLT_not_activated(list_of_bytes):
  
      # list length is not 2
      if (list_of_bytes[0] != 2):
          return False
      end
  
      # first byte is '0'?
      if (list_of_bytes[1] != 48):
          return False
      end
  
      # second byte is '7'?
      if (list_of_bytes[2] != 55):
          return False
      end
  
      return True
  end
  
  def is_FLT_autorelease_in_progress(list_of_bytes):
  
      # list length is not 2
      if (list_of_bytes[0] != 2):
          return False
      end
  
      # first byte is '1'?
      if (list_of_bytes[1] != 49):
          return False
      end
  
      # second byte is '1'?
      if (list_of_bytes[2] != 49):
          return False
      end
  
      return True
  
  end
  
  def is_FLT_overcurrent(list_of_bytes):
  
      # list length is not 2
      if (list_of_bytes[0] != 2):
          return False
      end
  
      # first byte is '1'?
      if (list_of_bytes[1] != 49):
          return False
      end
  
      # second byte is '4'?
      if (list_of_bytes[2] != 52):
          return False
      end
  
      return True
  
  end
  
  def is_FLT_autorelease_completed(list_of_bytes):
  
      # list length is not 2
      if (list_of_bytes[0] != 2):
          return False
      end
  
      # first byte is '1'?
      if (list_of_bytes[1] != 49):
          return False
      end
  
      # second byte is '5'?
      if (list_of_bytes[2] != 53):
          return False
      end
  
      return True
  
  end
  
  def rq_set_var(var_name, var_value, gripper_socket="1"):
  
      var_name_string = ""
  
      if (var_name == ACT):
          var_name_string = "ACT"
      elif (var_name == GTO):
          var_name_string = "GTO"
      elif (var_name == ATR):
          var_name_string = "ATR"
      elif (var_name == ARD):
          var_name_string = "ARD"
      elif (var_name == FOR):
          var_name_string = "FOR"
      elif (var_name == SPE):
          var_name_string = "SPE"
      elif (var_name == POS):
          var_name_string = "POS"
      elif (var_name == LBP):
          var_name_string = "LBP"
      elif (var_name == LRD):
          var_name_string = "LRD"
      elif (var_name == LBL):
          var_name_string = "LBL"
      elif (var_name == LGN):
          var_name_string = "LGN"
      elif (var_name == MSC):
          var_name_string = "MSC"
      end
  
      enter_critical
      socket_set_var(var_name_string, var_value, gripper_socket)
      sync()
      ack = socket_read_byte_list(3, gripper_socket)
      exit_critical
  
      sync()
  
      while(is_not_ack(ack)):
          enter_critical
          socket_set_var(var_name_string , var_value, gripper_socket)
          sync()
          ack = socket_read_byte_list(3, gripper_socket)
          exit_critical
  
          sync()
      end
  end
  
  
  def rq_get_var(var_name, nbr_bytes, gripper_socket="1"):
      enter_critical
  
      if (var_name == FLT):
          socket_send_string("GET FLT",gripper_socket)
      elif (var_name == OBJ):
          socket_send_string("GET OBJ",gripper_socket)
      elif (var_name == STA):
          socket_send_string("GET STA",gripper_socket)
      elif (var_name == PRE):
          socket_send_string("GET PRE",gripper_socket)
      else:
      end
  
      exit_critical
  
      sync()
  
      enter_critical
      var_value = socket_read_byte_list(nbr_bytes, gripper_socket)
      exit_critical
  
      sync()
  
      return var_value
  end
  
  def rq_is_object_validated(gripper_selected, gripper_socket="1"):
      if(gripper_selected):
          if(rq_is_object_detected(gripper_socket)):
              return True
          else:
              return False
          end
      else:
          return True
      end
  end
  
  ############################################
  # normalized functions (maps 0-100 to 0-255)
  ############################################
  def rq_set_force_norm(force_norm, gripper_socket="1"):
      force_gripper = norm_to_gripper(force_norm)
      rq_set_force(force_gripper, gripper_socket)
  end
  
  def rq_set_speed_norm(speed_norm, gripper_socket="1"):
      speed_gripper = norm_to_gripper(speed_norm)
      rq_set_speed(speed_gripper, gripper_socket)
  end
  
  def rq_move_norm(pos_norm, gripper_socket="1"):
      pos_gripper = norm_to_gripper(pos_norm)
      rq_move(pos_gripper, gripper_socket)
  end
  
  def rq_move_and_wait_norm(pos_norm, gripper_socket="1"):
      pos_gripper = norm_to_gripper(pos_norm)
      rq_move_and_wait(pos_gripper, gripper_socket)
  end
  
  def rq_set_pos_norm(pos_norm, gripper_socket="1"):
      pos_gripper = norm_to_gripper(pos_norm)
      rq_set_pos(pos_gripper, gripper_socket)
  end
  
  def rq_current_pos_norm(gripper_socket="1"):
      pos_gripper = rq_current_pos(gripper_socket)
      pos_norm = gripper_to_norm(pos_gripper)
      return pos_norm
  end
  
  def gripper_to_norm(value_gripper):
      value_norm = (value_gripper / 255) * 100
      return floor(value_norm)
  end
  
  def norm_to_gripper(value_norm):
      value_gripper = (value_norm / 100) * 255
      return ceil(value_gripper)
  end
  
  def rq_get_position():
      return rq_current_pos_norm()
  end
  
  def rq_gripper_led_on(gripper_socket="1"):
      rq_set_var(LBP,0, gripper_socket)
  end
  
  def rq_gripper_led_off(gripper_socket="1"):
      rq_set_var(LBP,1, gripper_socket)
      rq_set_var(LRD,0, gripper_socket)
      rq_set_var(LBL,0, gripper_socket)
      rq_set_var(LGN,0, gripper_socket)
  end
  
  def rq_gripper_led_force_red(gripper_socket="1"):
      rq_set_var(LBP,1, gripper_socket)
      rq_set_var(LRD,1, gripper_socket)
      rq_set_var(LBL,0, gripper_socket)
      rq_set_var(LGN,0, gripper_socket)
  end
  
  def rq_gripper_led_force_blue(gripper_socket="1"):
      rq_set_var(LBP,1, gripper_socket)
      rq_set_var(LRD,0, gripper_socket)
      rq_set_var(LBL,1, gripper_socket)
      rq_set_var(LGN,0, gripper_socket)
  end
  
  def rq_gripper_led_force_green(gripper_socket="1"):
      rq_set_var(LBP,1, gripper_socket)
      rq_set_var(LRD,0, gripper_socket)
      rq_set_var(LBL,0, gripper_socket)
      rq_set_var(LGN,1, gripper_socket)
  end
  
  def rq_gripper_led_force_purple(gripper_socket="1"):
      rq_set_var(LBP,1, gripper_socket)
      rq_set_var(LRD,1, gripper_socket)
      rq_set_var(LBL,1, gripper_socket)
      rq_set_var(LGN,0, gripper_socket)
  end
  
  ############################################
  # mm/inches functions
  ############################################
  gripper_closed_norm = [100, 100, 100, 100]
  gripper_open_norm = [0, 0, 0, 0]
  gripper_closed_mm = [0, 0, 0, 0]
  gripper_open_mm = [50, 50, 50, 50]
  
  def rq_current_pos_mm(gripper_socket=1):
      pos_gripper = rq_current_pos(gripper_socket)
      pos_mm = gripper_to_mm(pos_gripper, gripper_socket)
      return round_value_2_dec(pos_mm)
  end
  
  def rq_current_pos_inches(gripper_socket=1):
      pos_gripper = rq_current_pos(gripper_socket)
      pos_mm = gripper_to_mm(pos_gripper, gripper_socket)
      pos_in = pos_mm / 25.4
      return round_value_2_dec(pos_in)
  end
  
  def rq_move_mm(pos_mm, gripper_socket=1):
      pos_gripper = mm_to_gripper(pos_mm, gripper_socket)
      rq_move(pos_gripper, gripper_socket)
  end
  
  def rq_move_and_wait_mm(pos_mm, gripper_socket=1):
      pos_gripper = mm_to_gripper(pos_mm, gripper_socket)
      rq_move_and_wait(pos_gripper, gripper_socket)
  end
  
  def rq_move_inches(pos_in, gripper_socket=1):
      pos_mm = pos_in * 25.4
      rq_move_mm(pos_mm, gripper_socket)
  end
  
  def rq_move_and_wait_inches(pos_in, gripper_socket=1):
      pos_mm = pos_in * 25.4
      rq_move_and_wait_mm(pos_mm, gripper_socket)
  end
  
  def get_closed_norm(gripper_socket):
      return gripper_closed_norm[gripper_socket - 1]
  end
  
  def get_open_norm(gripper_socket):
      return gripper_open_norm[gripper_socket - 1]
  end
  
  def get_closed_mm(gripper_socket):
      return gripper_closed_mm[gripper_socket - 1]
  end
  
  def get_open_mm(gripper_socket):
      return gripper_open_mm[gripper_socket - 1]
  end
  
  def set_closed_norm(closed_norm, gripper_socket):
      gripper_closed_norm[gripper_socket - 1] = closed_norm
  end
  
  def set_open_norm(open_norm, gripper_socket):
      gripper_open_norm[gripper_socket - 1] = open_norm
  end
  
  def set_closed_mm(closed_mm, gripper_socket):
      gripper_closed_mm[gripper_socket - 1] = closed_mm
  end
  
  def set_open_mm(open_mm, gripper_socket):
      gripper_open_mm[gripper_socket - 1] = open_mm
  end
  
  def gripper_to_mm(value_gripper, gripper_socket):
      closed_norm = get_closed_norm(gripper_socket)
      open_norm = get_open_norm(gripper_socket)
      closed_mm = get_closed_mm(gripper_socket)
      open_mm = get_open_mm(gripper_socket)
  
      value_norm = (value_gripper / 255) * 100
  
      slope = (closed_mm - open_mm) / (closed_norm - open_norm)
      value_mm = slope * (value_norm - closed_norm) + closed_mm
  
      if (value_mm > open_mm):
          value_mm_limited = open_mm
      elif (value_mm < closed_mm):
          value_mm_limited = closed_mm
      else:
          value_mm_limited = value_mm
      end
  
      return value_mm_limited
  end
  
  def mm_to_gripper(value_mm, gripper_socket):
      closed_norm = get_closed_norm(gripper_socket)
      open_norm = get_open_norm(gripper_socket)
      closed_mm = get_closed_mm(gripper_socket)
      open_mm = get_open_mm(gripper_socket)
  
      slope = (closed_norm - open_norm) / (closed_mm - open_mm)
      value_norm = (value_mm - closed_mm) * slope + closed_norm
  
      value_gripper = value_norm * 255 / 100
  
      if (value_gripper > 255):
          value_gripper_limited = 255
      elif (value_gripper < 0):
          value_gripper_limited = 0
      else:
          value_gripper_limited = round_value(value_gripper)
      end
  
      return value_gripper_limited
  end
  
  def round_value(value):
      value_mod = value % 1
  
      if(value_mod < 0.5):
          return floor(value)
      else:
          return ceil(value)
      end
  end
  
  def round_value_2_dec(value):
      value_x_100 = value * 100
      value_x_100_rounded = round_value(value_x_100)
      return value_x_100_rounded / 100
  end
  
  def clear_socket_buffer(gripper_socket="1"):
    read_timeout = 0.1
  
    byte_in_buffer = socket_read_byte_list(1, gripper_socket, read_timeout)
  
    while(byte_in_buffer[0] >= 1):
        byte_in_buffer = socket_read_byte_list(1, gripper_socket, read_timeout)
    end
  end
  #########################################
  
  
  rq_obj_detect = 0
  rq_init_comm_if_connected(9, "1")
  rq_init_comm_if_connected(2, "2")
  rq_init_comm_if_connected(3, "3")
  rq_init_comm_if_connected(4, "4")
  rq_print_connected_grippers()
  connectivity_checked = [-1,-1,-1,-1]
  status_checked = [-1,-1,-1,-1]
  current_speed = [-1,-1,-1,-1]
  current_force = [-1,-1,-1,-1]
  set_closed_norm(90.19607843137256, 1)
  set_open_norm(2.3529411764705883, 1)
  set_closed_mm(0.0, 1)
  set_open_mm(85.0, 1)
  set_closed_norm(89.80392156862744, 2)
  set_open_norm(1.1764705882352942, 2)
  set_closed_mm(0.0, 2)
  set_open_mm(85.0, 2)
  set_closed_norm(100.0, 3)
  set_open_norm(0.0, 3)
  set_closed_mm(0.0, 3)
  set_open_mm(50.0, 3)
  set_closed_norm(100.0, 4)
  set_open_norm(0.0, 4)
  set_closed_mm(0.0, 4)
  set_open_mm(50.0, 4)
  # end: URCap Installation Node
  $ 1 "BeforeStart"
  $ 2 "MoveJ"
  $ 3 "home"
  movej(get_inverse_kin(p[.349217392940, -.141392341873, .524159785980, -1.347778079382, 1.130857901652, -1.293538668250], qnear=[-0.11751443544496709, -1.3174932638751429, -2.00149375597109, 0.15387821197509766, 1.710980772972107, -0.16084272066225225]), a=1.3962634015954636, v=1.0471975511965976)
  while (True):
    $ 4 "Robot Program"
    $ 5 "startPose≔get_actual_tcp_pose()"
    global startPose= get_actual_tcp_pose ()
    $ 6 "r≔d2r(5*(L_upDown-100)/100)"
    global r=d2r(5*(modbus_get_signal_status("L_upDown")-100)/100)
    $ 7 "p≔d2r(5*(L_leftRright-100)/100)"
    global p=d2r(5*(modbus_get_signal_status("L_leftRright")-100)/100)
    $ 8 "yaw≔d2r(5*(R_leftRight-100)/100)"
    global yaw=d2r(5*(modbus_get_signal_status("R_leftRight")-100)/100)
    $ 9 "rVector≔rpy2rotvec([r,p,yaw])"
    global rVector=rpy2rotvec([r,p,yaw])
    $ 10 "rx≔rVector[0]"
    global rx=rVector[0]
    $ 11 "ry≔rVector[1]"
    global ry=rVector[1]
    $ 12 "rz≔rVector[2]"
    global rz=rVector[2]
    $ 13 "startPose≔pose_trans(startPose,p[0,0,0,rx,ry,rz])"
    global startPose=pose_trans(startPose,p[0,0,0,rx,ry,rz])
    $ 14 "endPose≔pose_trans(startPose,p[0,0,-0.05*(R_upDown-100)/100,0,0,0])"
    global endPose=pose_trans(startPose,p[0,0,-0.05*(modbus_get_signal_status("R_upDown")-100)/100,0,0,0])
    $ 15 "MoveJ"
    $ 16 "endPose"
    movej(endPose, a=1.3962634015954636, v=1.0471975511965976)
    $ 17 "stopj(20)"
    stopj(20)
    $ 18 "Wait: 0.1"
    sleep(0.1)
  end
end
